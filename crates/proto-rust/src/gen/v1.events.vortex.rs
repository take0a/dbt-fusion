// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VortexMessage {
    /// this can encapsulate any known protobuf message type.
    ///
    /// <https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/any.proto>
    #[prost(message, optional, tag = "1")]
    pub any: ::core::option::Option<::pbjson_types::Any>,
    /// the time that the event was created by the client. this could
    /// be different than the time that the event was sent to vortex,
    /// since the client may buffer events before sending them.
    #[prost(message, optional, tag = "2")]
    pub vortex_event_created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    /// the time that the client sent the message to vortex (recorded
    /// by the vortex client library automatically).
    #[prost(message, optional, tag = "3")]
    pub vortex_client_sent_at: ::core::option::Option<::pbjson_types::Timestamp>,
    /// the time that the vortex api received the message.
    #[prost(message, optional, tag = "4")]
    pub vortex_backend_received_at: ::core::option::Option<::pbjson_types::Timestamp>,
    /// the time that the vortex backend fully processed the message.
    #[prost(message, optional, tag = "5")]
    pub vortex_backend_processed_at: ::core::option::Option<::pbjson_types::Timestamp>,
}
impl ::prost::Name for VortexMessage {
    const NAME: &'static str = "VortexMessage";
    const PACKAGE: &'static str = "v1.events.vortex";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.events.vortex.VortexMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.events.vortex.VortexMessage".into()
    }
}
/// internal canonical message for vortex events. this is what
/// you receive when you integrate a streaming consumer with vortex.
/// it is also what vortex uses internally on its queue.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VortexMessageBatch {
    /// a UUID which is a unique identifier for the event, it can be
    /// provided by the client or autogenerated by the vortex  client
    /// library.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// the data that was sent to vortex originally. it is retained
    /// here so that consumers can re-construct the original message
    /// exactly as they sent it. clients will construct this from
    /// a valid protobuf message.
    ///
    /// each batch can contain many different message types. this
    /// will be hidden away from streaming consumers, who will instead
    /// see the exact protobufs requested come through in their
    /// subscription.
    #[prost(message, repeated, tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<VortexMessage>,
}
impl ::prost::Name for VortexMessageBatch {
    const NAME: &'static str = "VortexMessageBatch";
    const PACKAGE: &'static str = "v1.events.vortex";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.events.vortex.VortexMessageBatch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.events.vortex.VortexMessageBatch".into()
    }
}
/// a message that is sent to the dead letter queue when a message
/// is rejected by vortex.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VortexDeadLetterMessage {
    /// type url of failed message
    #[prost(string, tag = "1")]
    pub type_url: ::prost::alloc::string::String,
    /// a best effort attempt at serializing the rejected message.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    /// original bytes of failed message (for reconstructing or replaying events).
    #[prost(bytes = "vec", tag = "3")]
    pub value_bytes: ::prost::alloc::vec::Vec<u8>,
    /// the reason that the message was rejected.
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
}
impl ::prost::Name for VortexDeadLetterMessage {
    const NAME: &'static str = "VortexDeadLetterMessage";
    const PACKAGE: &'static str = "v1.events.vortex";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.events.vortex.VortexDeadLetterMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.events.vortex.VortexDeadLetterMessage".into()
    }
}
/// Base enriched event data that all telemetry events inherit from
/// Should be explicitly defined as a field "enrichment"
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VortexMessageEnrichment {
    /// IP address and proxy information of the client
    #[prost(message, optional, tag = "1")]
    pub client_ip: ::core::option::Option<VortexClientIp>,
    /// Information about the client platform, including service, client, and library versions
    #[prost(message, optional, tag = "2")]
    pub client_platform: ::core::option::Option<VortexClientPlatform>,
    /// User agent information for web-based events
    #[prost(message, optional, tag = "3")]
    pub user_agent: ::core::option::Option<VortexUserAgent>,
}
impl ::prost::Name for VortexMessageEnrichment {
    const NAME: &'static str = "VortexMessageEnrichment";
    const PACKAGE: &'static str = "v1.events.vortex";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.events.vortex.VortexMessageEnrichment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.events.vortex.VortexMessageEnrichment".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VortexClientIp {
    /// The IP address of the client
    #[prost(string, tag = "1")]
    pub ip: ::prost::alloc::string::String,
    /// Whether the IP address is from a proxy service
    #[prost(bool, tag = "2")]
    pub proxy: bool,
    /// Geographic location information for this IP address
    #[prost(message, optional, tag = "3")]
    pub geo: ::core::option::Option<VortexGeolocation>,
}
impl ::prost::Name for VortexClientIp {
    const NAME: &'static str = "VortexClientIp";
    const PACKAGE: &'static str = "v1.events.vortex";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.events.vortex.VortexClientIp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.events.vortex.VortexClientIp".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VortexGeolocation {
    /// Two-letter country code (ISO 3166-1 alpha-2)
    #[prost(string, tag = "1")]
    pub country: ::prost::alloc::string::String,
    /// Name of the city
    #[prost(string, tag = "2")]
    pub city: ::prost::alloc::string::String,
    /// Latitude coordinate
    #[prost(double, tag = "3")]
    pub latitude: f64,
    /// Longitude coordinate
    #[prost(double, tag = "4")]
    pub longitude: f64,
    /// Timezone identifier (e.g., "America/New_York")
    #[prost(string, tag = "5")]
    pub timezone: ::prost::alloc::string::String,
    /// Name of the continent
    #[prost(string, tag = "6")]
    pub continent: ::prost::alloc::string::String,
}
impl ::prost::Name for VortexGeolocation {
    const NAME: &'static str = "VortexGeolocation";
    const PACKAGE: &'static str = "v1.events.vortex";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.events.vortex.VortexGeolocation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.events.vortex.VortexGeolocation".into()
    }
}
/// Client platform info that every vortex client will set via X-Vortex-Client-Platform
/// Expected format is "dbt-core/1.7.0 dbt-vortex-python/1.0.0 dbtlabs-proto/4.25.1"
/// See <https://github.com/dbt-labs/vortex/pull/101> for more context
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VortexClientPlatform {
    /// Full header value as received
    #[prost(string, tag = "1")]
    pub raw: ::prost::alloc::string::String,
    /// Source service of the vortex client (i.e. dbt-core)
    #[prost(string, tag = "2")]
    pub service: ::prost::alloc::string::String,
    /// Version of the source service
    #[prost(string, tag = "3")]
    pub service_version: ::prost::alloc::string::String,
    /// Vortex client used (i.e. vortex-client-rust)
    #[prost(string, tag = "4")]
    pub client: ::prost::alloc::string::String,
    /// Version of the vortex client
    #[prost(string, tag = "5")]
    pub client_version: ::prost::alloc::string::String,
    /// Name of the dbt proto library used
    #[prost(string, tag = "6")]
    pub dbt_proto_library: ::prost::alloc::string::String,
    /// Version of the dbt proto library
    #[prost(string, tag = "7")]
    pub dbt_proto_library_version: ::prost::alloc::string::String,
}
impl ::prost::Name for VortexClientPlatform {
    const NAME: &'static str = "VortexClientPlatform";
    const PACKAGE: &'static str = "v1.events.vortex";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.events.vortex.VortexClientPlatform".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.events.vortex.VortexClientPlatform".into()
    }
}
/// For web based events that send the User-Agent header
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VortexUserAgent {
    /// Raw User-Agent string as received from the client
    #[prost(string, tag = "1")]
    pub raw: ::prost::alloc::string::String,
    /// Name of the browser (e.g., "Chrome", "Firefox")
    #[prost(string, tag = "2")]
    pub browser: ::prost::alloc::string::String,
    /// Version of the browser
    #[prost(string, tag = "3")]
    pub browser_version: ::prost::alloc::string::String,
    /// Operating system name (e.g., "Windows", "macOS")
    #[prost(string, tag = "4")]
    pub os: ::prost::alloc::string::String,
    /// Operating system version
    #[prost(string, tag = "5")]
    pub os_version: ::prost::alloc::string::String,
    /// Device model or identifier
    #[prost(string, tag = "6")]
    pub device: ::prost::alloc::string::String,
    /// Type of device (e.g., "mobile", "desktop", "tablet")
    #[prost(string, tag = "7")]
    pub device_type: ::prost::alloc::string::String,
}
impl ::prost::Name for VortexUserAgent {
    const NAME: &'static str = "VortexUserAgent";
    const PACKAGE: &'static str = "v1.events.vortex";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.events.vortex.VortexUserAgent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.events.vortex.VortexUserAgent".into()
    }
}
